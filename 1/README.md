## Проект 1: ssl сертификаты: основы. генерируем ключи, запросы и сертификаты - без стороннего CA (== self-signed)

пошаговый проект для понимания ключей и сертификатов<br>
1. [создание RSA ключа (KEY) и CSR запроса](1/)
2. [создание только RSA ключа](2/)
3. [CSR запрос, имея закрый ключ (KEY)](3/)
4. [сертификат CRT из закрытого ключа (KEY) и запроса CSR](4/)
5. [CSR запрос из существующих CRT и закрытого ключа (KEY)](5/)
6. [закрытый ключ (KEY) и CRT одной командой](6/)
7. [X509 CRT, имея закрытый ключ](7/)
8. [просмотр данных CSR и CRT + проверка соответствия ключей](8/)


### Главное

по сути, private KEY и CRT - пара приватный(закрытый) и публичный(открытый) ключей<br>
они необходимы для УСТАНОВКИ соединения - асимметричное шифрование<br>
дальше в соединении юзается легкое симметричное шифрование. и эти ключ и сертификат не нужны (до следующего соединения)<br>
публичный ключ нигде не фигурирует в чистом виде. а скрывается внутри CSR и CRT, поэтому их как раз таки часто называют публичным ключом - в рамках HTTPS соединения это допустимо, но в терминологии PKI нет, т.е. при работе с openssl<br>
CSR ~= публичный ключ. точнее, он включает публичный ключ + доп инфо<br>
CSR ~= CRT, но не имеет цифровую подпись trusted CA. "полуфабрикат"<br>
CRT ~= публичный ключ. точнее, он включает публичный ключ + доп инфо + цифровую подпись trusted CA<br>
с момента, как есть сертификат CRT, запрос на подпись CSR больше не нужен<br>


### Термины

#### CSR (Certificate Signing Request)
* файл, содержащий информацию о субъекте (например, человеке, организации или сервере), запрашивающем сертификат
* включает в себя такие данные, как доменное имя, название организации и местоположение, а также public key, который будет включен в сертификат
* это форма заявки на получение сертификата SSL - отправляется в центр сертификации (CA)
* не включает закрытый ключ - он содержит только открытый ключ и метаданные о запрашивающей стороне

при создании CSR openssl спросит пароль для запроса<br>
```
A challenge password []:<br>
```
это опционально. challenge password - часть стандарта PKCS #10<br>
используется для auth запрашивающего перед Certificate Authority (CA)<br>
это общий секрет между моим сервером и CA<br>
CA может требовать его. но чаще нет, т.к. это уже legacy фича<br>


#### Сертификат (.crt)
* Сертификат выдается by CA после проверки информации в CSR
* привязывает public key к данным субъекта (например, доменное имя, организация, etc)
* это не публичный ключ, но включает его. заверен (имеет цифровую подпись) trusted CA и является удостоверением как паспорт (с данными о компании)
* Файл .crt фактически используется на сервере/приложении для включения шифрования SSL/TLS
* при создании не требует пароля, в отличие от CSR, потому что CRT - открытый, в нем только инфо об организации и публичный ключ - его все могут и должны читать
* имеет расширения .pem, .crt/.cer/.cert, .der, .pfx/.p12 (PKCS #12)


### Порядок общения:
* генерится пара ключей: открытый(публичный) и закрытый(приватный) - это на сервере
* закрытый ключ, в отличие от работы клиента с GitHub, это секрет сервера и остается на нем в единственном экземпляре
* генерится CSR. в этом проекте pubkey нигде не фигурирует - он содержится CSR (и далее в CRT)
* создается CRT - CSR подписывается через CA. после этого CSR не нужен. при генерации самоподписанного CRT стадию с CSR тоже можно пропустить
* CRT включает в себя public key - мы можем раздавать его всему миру (с сервера)
* на web-сервере (например nginx) в конфиг вставляются private key и CRT сервера. KEY - для шифрования во время установки соединения, а CRT - чтобы дать его клиенту по запросу
* Клиенты не хранят SSL сертификат моего сервера постоянно и тем более в системе
* Клиенты в своей OS хранят trusted Certificate Authorities (CA), которые есть с момента установки системы
* клиент (браузер/приложение) инициирует SSL соединение с сервером, сервер отправляет свой сертификат SSL клиенту
* клиент проверяет сертификат SSL сервера, что он valid и trusted - проверка signature сертификата с помощью доверенных CA (хранятся в OS клиента)
* клиент извлекает из CRT открытый ключ - он используется для шифрования данных (например, симметричного ключа сеанса) во время установления соединения
* сбщ шифруется открытым ключом (из CRT). он есть у всех одинаковый (сервер, клиент, злоумышленник) - зашифровать сбщ может каждый
* расшифровывается только с помощью закрытого - сервером. из сообщения извлекается симметричный ключ сеанса
* это была только установка соединения (асимметричное шифрование) - обмен ключами (симметричными), ну или передача клиентом серверу симметричного ключа
* далее соединение шифруется с помощью симметричного ключа для эффективности. но без асимметричной установки соединения теряет смысл
* После установления соединения (TLS/SSL handshake) сертификат удаляется на клиенте. Исключение: кэширование сертификатов на клиенте (браузере) во время сеанса - этот кэш обычно очищается по завершении сеанса (при закрытии браузера)
